// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../../../babylonjs
//   ../../../litegraph.js

declare module 'babylonjs-editor' {
    import Extensions from 'babylonjs-editor/extensions';
    import Extension from 'babylonjs-editor/extension';
    import AssetsExtension from 'babylonjs-editor/assets/assets';
    import CodeExtension from 'babylonjs-editor/behavior/code';
    import GraphExtension, { LGraph, LGraphCanvas, LiteGraph, GraphNode, LGraphGroup } from 'babylonjs-editor/behavior/graph';
    import PathFinderExtension from 'babylonjs-editor/path-finder/index';
    import PostProcessEditorExtension from 'babylonjs-editor/post-process-editor/post-process-editor';
    import MaterialEditorExtension from 'babylonjs-editor/material-editor/material-editor';
    import PostProcessExtension from 'babylonjs-editor/post-process/post-processes';
    import CustomMetadatasExtension from 'babylonjs-editor/metadata/metadatas';
    import { IExtension, ExtensionConstructor } from 'babylonjs-editor/typings/extension';
    export { Extensions, Extension, AssetsExtension, CodeExtension, GraphExtension, LGraph, LGraphCanvas, LiteGraph, GraphNode, LGraphGroup, PostProcessExtension, MaterialEditorExtension, PathFinderExtension, PostProcessEditorExtension, CustomMetadatasExtension, IExtension, ExtensionConstructor };
}

declare module 'babylonjs-editor/extensions' {
    import { Scene } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import { IExtension, ExtensionConstructor } from 'babylonjs-editor/typings/extension';
    import Tools from 'babylonjs-editor/tools/tools';
    import Mobile from 'babylonjs-editor/tools/mobile';
    export default class Extensions {
            static Extensions: IStringDictionary<ExtensionConstructor<any>>;
            static Instances: IStringDictionary<IExtension<any>>;
            static OrderedExtensions: string[];
            /**
                * Reference to tools used by extensions.
                */
            static Tools: Tools;
            /**
                * Reference to all mobile tools (vibrate, etc.).
                */
            static Mobile: Mobile;
            /**
                * Sets or gets the current Root Url used while loading assets and extensions.
                */
            static RootUrl: string;
            /**
             * @deprecated please use RootUrl instead.
             */
            static RoolUrl: string;
            /**
                * Registers an extension
                * @param extension the extension to register
                */
            static Register<T>(name: string, extension: ExtensionConstructor<T>): boolean;
            /**
                * Requests an extension: returns the already created
                * if already exists
                * @param name the name of the extension
                */
            static RequestExtension<T extends IExtension<any>>(scene: Scene, name: string): T;
            /**
                * Applies all extesions giving all the custom metadatas
                * @param metadatas the metadatas for all extensions
                */
            static ApplyExtensions(scene: Scene, metadatas: IStringDictionary<any>): void;
            /**
                * Clears all the extensions
                */
            static ClearExtensions(): void;
    }
}

declare module 'babylonjs-editor/extension' {
    import { Scene } from 'babylonjs';
    import { IExtension } from 'babylonjs-editor/typings/extension';
    export default abstract class Extension<T> implements IExtension<T> {
            scene: Scene;
            datas: T;
            alwaysApply: boolean;
            /**
                * Constructor
                * @param scene: the scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            abstract onApply(data: T, rootUrl?: string): void;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            abstract onLoad(data: T): void;
            /**
                * Adds a script tag element to the dom including source URL
                * @param code: the code's text
                * @param url: the URL of the script to show in devtools
                */
            static AddScript(code: string, url: string): HTMLScriptElement;
    }
}

declare module 'babylonjs-editor/assets/assets' {
    import { Node, Scene, ParticleSystemSet, Vector3 } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { AssetElement } from 'babylonjs-editor/typings/asset';
    /**
        * Assets type used as alias
        */
    export interface ProjectAssets {
            prefabs: AssetElement<any>[];
            particles: AssetElement<any>[];
    }
    export default class AssetsExtension extends Extension<ProjectAssets> {
            prefabs: AssetElement<any>[];
            particles: AssetElement<any>[];
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: ProjectAssets): void;
            /**
                * Instantiate a prefab identified by the given name
                * @param name the name of the prefab to instantiate
                */
            instantiatePrefab<T extends Node>(name: string): T;
            /**
                * Instantiates a particle system set identified by the given name
                * @param name the name of the particle system set to instantiate
                * @param position the position where to start systems
                */
            instantiateParticleSystemsSet(name: string, position?: Vector3): ParticleSystemSet;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): ProjectAssets;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: ProjectAssets): void;
    }
}

declare module 'babylonjs-editor/behavior/code' {
    import { Scene, AbstractMesh } from 'babylonjs';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import { IAssetComponent, AssetElement } from 'babylonjs-editor/typings/asset';
    import Extension from 'babylonjs-editor/extension';
    export interface BehaviorCode {
            code: string;
            compiledCode?: string;
            name: string;
            id: string;
    }
    export interface BehaviorNodeCode {
            codeId: string;
            active: boolean;
            params?: any;
    }
    export interface BehaviorNodeMetadata {
            node: string;
            nodeId: string;
            metadatas: BehaviorNodeCode[];
    }
    export interface BehaviorMetadata {
            scripts: BehaviorCode[];
            nodes: BehaviorNodeMetadata[];
    }
    export module EDITOR {
            class BehaviorCode {
                    static Constructors: {};
            }
    }
    export default class CodeExtension extends Extension<BehaviorMetadata> implements IAssetComponent {
            id: string;
            assetsCaption: string;
            instances: IStringDictionary<any>;
            scriptsConstructors: IStringDictionary<any>;
            objectsInstances: IStringDictionary<any[]>;
            static Instance: CodeExtension;
            static CurrentDatas: BehaviorMetadata;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new code asset
                */
            onCreateAsset(name: string): Promise<AssetElement<any>>;
            /**
                * On the user renames the asset
                * @param asset the asset being renamed
                * @param name the new name of the asset
                */
            onRenameAsset(asset: AssetElement<BehaviorCode>, name: string): void;
            /**
                * On get all the assets to be drawn in the assets component
                */
            onGetAssets(): AssetElement<any>[];
            /**
                * On the user drops an asset
                * @param targetMesh the target mesh under the pointer
                * @param asset the asset being dropped
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<any>): void;
            /**
                * On the user wants to remove the asset
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<any>): void;
            /**
                * On the user adds an asset
                * @param asset the asset to add
                */
            onAddAsset(asset: AssetElement<any>): void;
            /**
                * On apply the extension
                */
            onApply(data: BehaviorMetadata): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): BehaviorMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: BehaviorMetadata): void;
            /**
                * Sets the custom params
                * @param m the behavior code structure
                * @param instance the instance
                */
            setCustomParams(m: BehaviorNodeCode, instance: any): void;
            /**
                * Return the constructor
                * @param code the code metadata
                * @param node the attached node
                * @param evaluate if the script should just be evaluated instead of injected in DOM
                */
            getConstructor(code: BehaviorCode, node: any, evaluate?: boolean): any;
            /**
                * Returns the given object's constructor name
                * @param obj the instance
                */
            getConstructorName(obj: any): string;
            /**
                * Returns the final typescript code
                * @param code: the behavior code metadata
                * @param node: the attached node
                */
            getFinalTypeScriptCode(code: BehaviorCode, node: any): string;
    }
}

declare module 'babylonjs-editor/behavior/graph' {
    import { Scene, AbstractMesh } from 'babylonjs';
    import { LGraph, LGraphCanvas, LiteGraph, LGraphGroup } from 'litegraph.js';
    import Extension from 'babylonjs-editor/extension';
    import { AssetElement } from 'babylonjs-editor/typings/asset';
    import { GraphNode } from 'babylonjs-editor/behavior/nodes/graph-node';
    export { LGraph, LGraphCanvas, LiteGraph, LGraphGroup, GraphNode };
    export interface Variable {
            /**
                * The name of the variable.
                */
            name: string;
            /**
                * The value of the variable.
                */
            value: string | boolean | number | number[];
    }
    export interface GraphData {
            graph: any;
            variables?: Variable[];
            name: string;
            id: string;
    }
    export interface NodeGraph {
            graphId: string;
            active: boolean;
    }
    export interface GraphNodeMetadata {
            node: string;
            nodeId: string;
            metadatas: NodeGraph[];
    }
    export interface BehaviorGraphMetadata {
            graphs: GraphData[];
            nodes: GraphNodeMetadata[];
    }
    export default class GraphExtension extends Extension<BehaviorGraphMetadata> {
            id: string;
            assetsCaption: string;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On get all the assets to be drawn in the assets component
                */
            onGetAssets(): AssetElement<any>[];
            /**
                * On the user wants to remove the asset
                * @param asset the asset to remove
                */
            onRemoveAsset(asset: AssetElement<any>): void;
            /**
                * On the user adds an asset
                * @param asset the asset to add
                */
            onAddAsset(asset: AssetElement<any>): void;
            /**
                * On the user drops an asset
                * @param targetMesh the target mesh under the pointer
                * @param asset the asset being dropped
                */
            onDragAndDropAsset(targetMesh: AbstractMesh, asset: AssetElement<any>): void;
            /**
                * On apply the extension
                */
            onApply(data: BehaviorGraphMetadata): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): BehaviorGraphMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: BehaviorGraphMetadata): void;
            /**
                * Clears all the additional nodes available for Babylon.js
                */
            static ClearNodes(): void;
            /**
                * Registers all the additional nodes available for Babylon.js
                * @param object the object which is attached
                */
            static RegisterNodes(object?: any): void;
    }
}

declare module 'babylonjs-editor/path-finder/index' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import PathFinder from 'babylonjs-editor/path-finder/path-finder';
    export interface PathFinderMetadata {
            name: string;
            size: number;
            rayHeight: number;
            rayLength: number;
            castMeshes: string[];
    }
    export default class PathFinderExtension extends Extension<PathFinderMetadata[]> {
            instances: IStringDictionary<PathFinder>;
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: PathFinderMetadata[]): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PathFinderMetadata[];
            /**
                * On load the extension (called by the editor when loading a scene)
                */
            onLoad(data: PathFinderMetadata[]): void;
    }
}

declare module 'babylonjs-editor/post-process-editor/post-process-editor' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import AbstractPostProcessEditor from 'babylonjs-editor/post-process-editor/post-process';
    export interface PostProcessCreatorUserConfig {
            textures?: {
                    value: any;
                    name: string;
            }[];
            floats?: {
                    value: number;
                    name: string;
            }[];
            vectors2?: {
                    value: number[];
                    name: string;
            }[];
            vectors3?: {
                    value: number[];
                    name: string;
            }[];
    }
    export interface PostProcessCreatorMetadata {
            cameraName: string;
            preview: boolean;
            name: string;
            code: string;
            compiledCode?: string;
            pixel: string;
            config: string;
            userConfig: PostProcessCreatorUserConfig;
            id: string;
    }
    export module EDITOR {
            class PostProcessCreator {
                    static Constructors: {};
            }
    }
    export default class PostProcessEditorExtension extends Extension<PostProcessCreatorMetadata[]> {
            instances: IStringDictionary<any>;
            static Instance: PostProcessEditorExtension;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new post-process
                * @param data: the data containing code, pixel, etc.
                */
            createPostProcess(data: PostProcessCreatorMetadata, rootUrl?: string): AbstractPostProcessEditor;
            /**
                * On apply the extension
                */
            onApply(data: PostProcessCreatorMetadata[], rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PostProcessCreatorMetadata[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: PostProcessCreatorMetadata[]): void;
    }
}

declare module 'babylonjs-editor/material-editor/material-editor' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    import { IStringDictionary } from 'babylonjs-editor/typings/typings';
    import CustomEditorMaterial from 'babylonjs-editor/material-editor/material';
    export interface MaterialCreatorUserConfig {
            textures?: {
                    value: any;
                    name: string;
            }[];
            floats?: {
                    value: number;
                    name: string;
            }[];
            vectors2?: {
                    value: number[];
                    name: string;
            }[];
            vectors3?: {
                    value: number[];
                    name: string;
            }[];
    }
    export interface MaterialCreatorMetadata {
            name: string;
            id?: string;
            code: string;
            compiledCode?: string;
            vertex: string;
            pixel: string;
            config: string;
            userConfig: MaterialCreatorUserConfig;
    }
    export module EDITOR {
            class MaterialCreator {
                    static Constructors: {};
            }
    }
    export default class MaterialEditorExtension extends Extension<MaterialCreatorMetadata[]> {
            instances: IStringDictionary<any>;
            static Instance: MaterialEditorExtension;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * Creates a new material
                * @param data: the data containing code, vertex, etc.
                */
            createMaterial(data: MaterialCreatorMetadata, rootUrl?: string): CustomEditorMaterial;
            /**
                * On apply the extension
                */
            onApply(data: MaterialCreatorMetadata[], rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): MaterialCreatorMetadata[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: MaterialCreatorMetadata[]): void;
    }
}

declare module 'babylonjs-editor/post-process/post-processes' {
    import { Scene, StandardRenderingPipeline, SSAO2RenderingPipeline, DefaultRenderingPipeline } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    export interface PostProcessMetadata {
            standard?: any;
            default?: any;
            ssao2?: any;
    }
    export default class PostProcessesExtension extends Extension<PostProcessMetadata> {
            standard: StandardRenderingPipeline;
            default: DefaultRenderingPipeline;
            ssao2: SSAO2RenderingPipeline;
            /**
                * Constructor
                * @param scene: the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: PostProcessMetadata, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): PostProcessMetadata;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: PostProcessMetadata): void;
    }
}

declare module 'babylonjs-editor/metadata/metadatas' {
    import { Scene } from 'babylonjs';
    import Extension from 'babylonjs-editor/extension';
    export interface CustomMetadatas {
            node: string;
            nodeId: string;
            metadatas: any;
    }
    export default class CustomMetadatasExtension extends Extension<CustomMetadatas[]> {
            /**
                * Constructor
                * @param scene the babylonjs scene
                */
            constructor(scene: Scene);
            /**
                * On apply the extension
                */
            onApply(data: CustomMetadatas[]): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize(): CustomMetadatas[];
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad(data: CustomMetadatas[]): void;
    }
}

declare module 'babylonjs-editor/typings/extension' {
    import { Scene } from 'babylonjs';
    import { IAssetComponent } from 'babylonjs-editor/typings/asset';
    /**
        * Interface representing an editor extension
        */
    export interface IExtension<T> extends IAssetComponent {
            /**
                * Sets if the extensions is always applied
                */
            alwaysApply: boolean;
            /**
                * On apply the extension
                */
            onApply(data: T, rootUrl?: string): void;
            /**
                * Called by the editor when serializing the scene
                */
            onSerialize?(): T;
            /**
                * On load the extension (called by the editor when
                * loading a scene)
                */
            onLoad?(data: T): void;
    }
    export type ExtensionConstructor<T> = new (scene: Scene) => IExtension<T>;
}

declare module 'babylonjs-editor/typings/typings' {
    export interface IStringDictionary<T> {
        [index: string]: T;
    }
}

declare module 'babylonjs-editor/tools/tools' {
    import { Node, Scene, ParticleSystem, ParticleSystemSet, Vector3 } from 'babylonjs';
    import PathFinder from 'babylonjs-editor/path-finder/path-finder';
    export default class Tools {
            /**
                * Returns a custom material by giving its name
                * @param name the name of the custom material
                */
            getCustomMaterial(name: string): any;
            /**
                * Returns a custom script given by its object attached to
                * and the name of the script
                * @param object the object containing the script
                * @param name the name of the script
                */
            getCustomScript(object: string | Node | ParticleSystem | Scene, name: string): any;
            /**
                * Returns the constructor of a script which has the given name
                * @param name the name of the script
                */
            getConstructor(name: string): any;
            /**
                * Returns the post-process by giving its name
                * @param name the name of the post-process
                */
            getCustomPostProcess(name: string): any;
            /**
                * Returns a file given by its name
                * @param name the name of the file
                */
            getFileByName(name: string): File;
            /**
                * Returns an object url for the given file
                * @param filename the reachable by the created URL
                * @param oneTimeOnly if the URL should be requested only one time
                */
            getFileUrl(filename: string, oneTimeOnly?: boolean): string;
            /**
                * Returns the given path finder according to the given name
                * @param name the name of the path finder
                */
            getPathFinder(name: string): PathFinder;
            /**
                * Instantiates a prefab identified by the given name
                * @param name the name of the prefab to instantiate
                */
            instantiatePrefab<T extends Node>(name: string): T;
            /**
                * Instantiates a particle system set identified by the given name
                * @param name the name of the particle system set to instantiate
                * @param position the position where to start systems
                */
            instantiateParticleSystemSet(name: string, position?: Vector3): ParticleSystemSet;
            /**
                * Calls the given method with the given parameters on the given object which has scripts providing the given method
                * @param object the object reference where to send the message by calling the given method name
                * @param methodName the method name to call with the given parameters
                * @param params the parameters to send to the script attached to the given object
                */
            sendMessage(object: Node | ParticleSystem | Scene, methodName: string, ...params: any[]): void;
    }
    export const exportScriptString: string;
}

declare module 'babylonjs-editor/tools/mobile' {
    export default class Mobile {
        /**
          * Calls the navigator to vibrate with the given pattern
          * @param pattern the vibration pattern
          */
        vibrate(pattern: number | number[]): boolean;
    }
}

declare module 'babylonjs-editor/typings/asset' {
    import { AbstractMesh, PickingInfo } from 'babylonjs';
    export interface AssetElement<T> {
        img?: string;
        name?: string;
        data?: T;
        separator?: string;
    }
    export interface AssetContextMenu {
        id: string;
        text: string;
        img?: string;
        callback?: (asset?: AssetElement<any>) => void;
    }
    export interface IAssetComponent {
        id?: string;
        assetsCaption?: string;
        size?: number;
        onCreateAsset?(name: string): AssetElement<any> | Promise<AssetElement<any>>;
        onRenameAsset?(asset: AssetElement<any>, name: string): void;
        onGetAssets?(): AssetElement<any>[] | Promise<AssetElement<any>[]>;
        onRemoveAsset?(asset: AssetElement<any>): void;
        onAddAsset?(asset: AssetElement<any>): void;
        onDragAndDropAsset?(targetMesh: AbstractMesh, asset: AssetElement<any>, pickInfo?: PickingInfo): void;
        onDoubleClickAsset?(asset: AssetElement<any>): void;
        onContextMenu?(): AssetContextMenu[];
        onSerializeAssets?(): AssetElement<any>[];
        onParseAssets?(data: AssetElement<any>[]): void;
    }
}

declare module 'babylonjs-editor/behavior/nodes/graph-node' {
    import { Scene, Node, Vector3, Vector2, Vector4, Color3, Color4 } from 'babylonjs';
    import { LGraphCanvas } from 'litegraph.js';
    import { IGraphNode, IGraphNodeDescriptor } from 'babylonjs-editor/behavior/nodes/types';
    /**
        * Registers the given node in order to be used.
        * @param description the description object of the node to add in the collection.
        * @param object defines the object being customized using the graph editor.
        */
    export function registerNode(description: IGraphNodeDescriptor, object: any): void;
    /**
        * Defines an input used for function execution.
        */
    export type ExecuteInput = {
            /**
                * The name of the input.
                */
            name: string;
            /**
                * The data of the input just being retrieved.
                */
            data: any;
    };
    export class GraphNode extends IGraphNode {
            description: IGraphNodeDescriptor;
            /**
                * Constructor.
                * @param description the description object of the node to add in the collection.
                */
            constructor(description: IGraphNodeDescriptor);
            /**
                * Can be implemented by the node, defines the list of available inputs not added by default to add on the fly.
                */
            onGetInputs(): [string, (string | number)][];
            /**
                * Can be implemented by the node, defines the list of available outputs not added by default to add on the fly.
                */
            onGetOutputs(): [string, (string | number)][];
            /**
                * Called on the node is being executed.
                */
            onExecute(): void;
            /**
                * On the background is drawn, draw custom text.
                * @param ctx the canvas 2d context reference.
                * @param graph the graph canvas reference.
                * @param canvas the canvas reference where to draw the text.
                * @param text the text to draw.
                */
            onDrawBackground(ctx: CanvasRenderingContext2D, graph: LGraphCanvas, canvas: HTMLCanvasElement, text?: string): void;
            /**
                * Called on the user releases a keyboard key.
                * @param ev the source keyboard event reference.
                * @todo support undo/redo
                */
            onKeyUp(ev: KeyboardEvent): void;
            /**
                * Returns wether or not the given value is valid.
                * @param value the value to check.
                */
            isInputValid(value: any): boolean;
            /**
                * Returns the effective property.
                * @param object the object reference containing the property to get.
                * @param path the path of the property to get its reference/copy.
                */
            static GetProperty<T>(object: any, path: string): T;
            /**
                * Returns the effective property.
                * @param object the object reference containing the property to get.
                * @param path the path of the property to get its reference/copy.
                */
            static GetEffectiveProperty<T>(object: any, path: string): T;
            /**
                * Returns the constructor name of the given object.
                * @param obj the object the get its constructor name.
                */
            static GetConstructorName(obj: any): string;
            /**
                * Returns the target (scene or not) according to the given path ('Scene' or node name).
                * @param path the path/name of the node/scene to get.
                * @param scene the scene reference.
                */
            static GetTargetPath(path: string, target: any, scene: Scene): Scene | Node;
            /**
                * Returns the value as expected for be used in the node.
                * @param value the value to convert to an understandable value for the node.
                */
            static inputToNode(value: any): number | string | number[];
            /**
                * Returns the value as expected for be used in the next node.
                * @param value the value to convert to an understandable value for the next node.
                */
            static nodeToOutput<T extends number | string | Vector2 | Vector3 | Vector4 | Color3 | Color4>(value: any, asColor?: boolean): T;
            /**
                * Works as a bypass to just return value.
                * @param value the value to return.
                */
            static commonToCommon(value: number | string): number | string;
            /**
                * Returns a new Vector3 from the given array.
                * @param vec2 the vec3 input as number[].
                */
            static vec2ToVector2(vec2: number[]): Vector2;
            /**
                * Returns the given vector 2d as number array.
                * @param vector2 the vector to transform as array.
                */
            static vector2ToVec2(vector2: Vector2): number[];
            /**
                * Returns a new Vector3 from the given array.
                * @param vec3 the vec3 input as number[].
                */
            static vec3ToVector3(vec3: number[]): Vector3;
            /**
                * Returns the given vector 3d as number array.
                * @param vector3 the vector to transform as array.
                */
            static vector3ToVec3(vector3: Vector3): number[];
            /**
                * Returns a new Vector4 from the given array.
                * @param vec4 the vec4 input as number[].
                */
            static vec4ToVector4(vec4: number[]): Vector4;
            /**
                * Returns the given vector 4d as number array.
                * @param vector4 the vector to transform as array.
                */
            static vector4ToVec4(vector4: Vector4): number[];
            /**
                * Returns a new Color 3 from the given array.
                * @param col3 the col3 input as number[].
                */
            static col3ToColor3(col3: number[]): Color3;
            /**
                * Returns the given color 3 as number array.
                * @param color3 the color to transform as array.
                */
            static color3ToCol3(color3: Color3): number[];
            /**
                * Returns a new Color 4 from the given array.
                * @param col4 the col4 input as number[].
                */
            static col4ToColor4(col4: number[]): Color4;
            /**
                * Returns the given color 4 as number array.
                * @param color3 the color to transform as array.
                */
            static color4ToCol4(color4: Color4): number[];
    }
}

declare module 'babylonjs-editor/path-finder/path-finder' {
    import { Vector3, BoundingInfo, AbstractMesh, Animation } from 'babylonjs';
    export default class PathFinder {
            graph: Graph;
            width: number;
            height: number;
            buffer: number[][];
            points: Vector3[];
            availablePoints: Vector3[];
            protected boundingInfo: BoundingInfo;
            /**
                * Constructor
                * @param size the path finder grid size
                */
            constructor(size: number);
            /**
                * Rebuilds the path's finder buffer
                * NOTE: should be done before creating the graph
                * @param size the path finder grid size
                */
            rebuildBuffers(size: number): void;
            /**
                * Get Vector3 path from the given start position to the given
                * end position
                * @param from the start position (typically the position of the object to move)
                * @param to the end position (typically already known or pre-programmed)
                * @param optimize if the extension should optimize the animation to be linear
                */
            fromTo(from: Vector3, to: Vector3, optimize?: boolean): Vector3[];
            /**
                * Creates a new animation from the given path
                * @param name the animation name being created
                * @param path the path containing the path points
                * @param framesPerSecond frames per second for the animation
                */
            createAnimation(name: string, path: Vector3[], framesPerSecond?: number): Animation;
            /**
                * Returns the nearest point
                * @param point the point reference
                */
            findNearestPoint(point: Vector3): Vector3;
            /**
                * Fills the graph with the given mesh surface geometry using ray
                * casting method.
                * @param castMeshes: surface meshes (holes are supported)
                * @param rayHeight the height of the rays to test collisions
                * @param rayLength the length of the rays to test collisions
                */
            fill(castMeshes: AbstractMesh[], rayHeight?: number, rayLength?: number): void;
    }
}

declare module 'babylonjs-editor/post-process-editor/post-process' {
    import { PostProcess, Effect, Scene, Camera, BaseTexture, Engine, Vector2, Vector3 } from 'babylonjs';
    /**
        * The custom post-process code interface which
        * comes from the user
        */
    export interface CustomPostProcessCode {
            init: () => void;
            setUniforms: (uniforms: string[], samplers: string[]) => void;
            onApply: (effect: Effect) => void;
            dispose: () => void;
    }
    /**
        * Custom post-process config
        */
    export interface CustomPostProcessConfig {
            ratio: number;
            textures: string[];
            floats: string[];
            vectors2: string[];
            vectors3: string[];
    }
    export default class AbstractPostProcessEditor extends PostProcess {
            customCode: CustomPostProcessCode;
            config: CustomPostProcessConfig;
            userConfig: {
                    [index: string]: number | Vector2 | Vector3 | BaseTexture;
            };
            protected scene: Scene;
            protected additionalUniforms: string[];
            protected additionalSamplers: string[];
            /**
                * Constructor
                * @param name: the name of the post-process
                * @param fragmentUrl: the url of the fragment shader
                * @param camera: the camera to attach to
                * @param ratio: the ratio of the post-process
                * @param customCode: the custom code from user
                */
            constructor(name: string, fragmentUrl: string, camera: Camera, engine: Engine, config: CustomPostProcessConfig, customCode: CustomPostProcessCode);
            /**
                * Sets the .onApply property of the post-process
                */
            setOnApply(): void;
            /**
                * Sets the post-process config
                * @param config
                */
            setConfig(config: CustomPostProcessConfig): void;
            /**
                * Disposes the post-process
                */
            dispose(): void;
            /**
                * Returns the post-process class name
                */
            getClassName(): string;
    }
}

declare module 'babylonjs-editor/material-editor/material' {
    import { Scene, MaterialDefines, PushMaterial, Nullable, BaseTexture, Color3, Matrix, Vector2, Vector3, AbstractMesh, SubMesh, Mesh, IAnimatable, Effect } from 'babylonjs';
    /**
        * Custom Material class
        */
    export class CustomMaterialDefines extends MaterialDefines {
            TEXTURE: boolean;
            CLIPPLANE: boolean;
            ALPHATEST: boolean;
            DEPTHPREPASS: boolean;
            POINTSIZE: boolean;
            FOG: boolean;
            NORMAL: boolean;
            UV1: boolean;
            UV2: boolean;
            VERTEXCOLOR: boolean;
            VERTEXALPHA: boolean;
            NUM_BONE_INFLUENCERS: number;
            BonesPerMesh: number;
            INSTANCES: boolean;
            constructor();
    }
    /**
        * The custom material code interface which
        * comes from the user
        */
    export interface CustomMaterialCode {
            init: () => void;
            setUniforms: (uniforms: string[], samplers: string[]) => void;
            isReadyForSubMesh: (mesh: AbstractMesh, subMesh: SubMesh, defines: CustomMaterialDefines) => boolean;
            bindForSubMesh: (world: Matrix, mesh: Mesh, subMesh: SubMesh, effect: Effect) => void;
            dispose: () => void;
    }
    export interface CustomMaterialConfig {
            textures: {
                    name: string;
                    isCube: boolean;
            }[];
            floats: string[];
            vectors2: string[];
            vectors3: string[];
    }
    /**
        * Custom material class
        */
    export default class CustomEditorMaterial extends PushMaterial {
            baseColor: Color3;
            disableLighting: boolean;
            maxSimultaneousLights: number;
            _shaderName: string;
            userConfig: {
                    [index: string]: number | Vector2 | Vector3 | BaseTexture;
            };
            config: CustomMaterialConfig;
            customCode: CustomMaterialCode;
            _buildId: number;
            /**
                * Constructor
                * @param name: the name of the material
                * @param scene: the scene reference
                */
            constructor(name: string, scene: Scene, shaderName: string, customCode: CustomMaterialCode, config: CustomMaterialConfig);
            setCustomCode(customCode: CustomMaterialCode): void;
            needAlphaBlending(): boolean;
            needAlphaTesting(): boolean;
            getAlphaTestTexture(): Nullable<BaseTexture>;
            isReadyForSubMesh(mesh: AbstractMesh, subMesh: SubMesh, useInstances?: boolean): boolean;
            bindForSubMesh(world: Matrix, mesh: Mesh, subMesh: SubMesh): void;
            getAnimatables(): IAnimatable[];
            getActiveTextures(): BaseTexture[];
            hasTexture(texture: BaseTexture): boolean;
            dispose(forceDisposeEffect?: boolean): void;
            clone(name: string): CustomEditorMaterial;
            serialize(): any;
            getClassName(): string;
            static Parse(source: any, scene: Scene, rootUrl: string): CustomEditorMaterial;
    }
}

declare module 'babylonjs-editor/behavior/nodes/types' {
    import { Scene, Vector2, Vector3, Vector4 } from 'babylonjs';
    import { LGraph, LGraphCanvas } from 'litegraph.js';
    import { GraphNode } from 'babylonjs-editor/behavior/nodes/graph-node';
    /**
        * Defines all possible inputs and outputs types.
        */
    export type InputOutputType = 'number' | 'string' | 'vec2' | 'vec3' | 'vec4' | 'col3' | 'col4' | string;
    /**
        * Defines all possibile types for nodes.
        */
    export type SupportedTypes = number | string | boolean | Vector2 | Vector3 | Vector4;
    /**
        * Defines the type of the function to call on a GraphNode.
        */
    export type GraphMethodCallType = (...args: any[]) => any;
    /**
        * Defines all possible options for widgets.
        */
    export interface IWidget {
            /**
                * The widge type.
                */
            type: 'allow' | 'button' | 'combo' | 'text' | 'slider' | string;
            /**
                * The name of the widget.
                */
            name: string;
            /**
                * The value of the widget.
                */
            value: any;
            /**
                * Called on the widget changed.
                */
            callback: (v: any, graph: LGraphCanvas, node: GraphNode) => void;
            /**
                * Options for the widget.
                */
            options?: {
                    /**
                        * Values used when widget is a combo.
                        */
                    values?: string[] | ((widget: IWidget, node: GraphNode) => void);
                    /**
                        * String used for toggle widgets, text to draw when value is "true"
                        */
                    on?: string;
                    /**
                        * String used for toggle widgets, text to draw when value is "false"
                        */
                    off?: string;
                    /**
                        * Numbers used for number widgets, used to set precision when sliding the value.
                        */
                    precision?: number;
                    /**
                        * Number used for slider widgets, used to set minimum value.
                        */
                    min?: number;
                    /**
                        * Number used for slider widgets, used to set maximum value.
                        */
                    max?: number;
                    /**
                        * Used only by editor, used to configure widget once node is instanciated
                        */
                    onInstanciate?: (node: GraphNode, widget: IWidget) => any;
            };
    }
    /**
        * Defines all possible options for a node.
        */
    export interface IGraphNodeDescriptor {
            /**
                * The name of the node.
                */
            name: string;
            /**
                * Defines the description of the node to draw in node edition tool.
                */
            description: string;
            /**
                * Represents the path of the node.
                * @example math/multiply.
                */
            path: string;
            /**
                * Defines the constructor where the node can be applied.
                * @example BABYLON.Node.
                */
            ctor: new (...args: any[]) => any;
            /**
                * Defines all the available inputs for the node.
                */
            inputs?: {
                    /**
                        * The name of the input.
                        */
                    name: string;
                    /**
                        * The type of input. Means the input value type.
                        */
                    type: InputOutputType;
                    /**
                        * Optional property path used to set the given property.
                        */
                    propertyPath?: string;
            }[];
            /**
                * Defines all the outputs avaiable for the node.
                */
            outputs?: {
                    /**
                        * The name of the output.
                        */
                    name: string;
                    /**
                        * The type of output. Means the output value type.
                        */
                    type: InputOutputType;
                    /**
                        * If outputs a property of the object, defines its path.
                        */
                    propertyPath?: string;
                    /**
                        * Defines the name of the property to output
                        * @see .properties in IGraphNodeDescriptor
                        */
                    propertyName?: string;
                    /**
                        * Defines the input name where to retrieve the data to output.
                        */
                    inputName?: string;
            }[];
            /**
                * The name of the function to call on the current object being used.
                * @see myGraphNode.graph.scriptObject;
                */
            functionRef?: string | ((node: GraphNode, target: any, scene: Scene) => any);
            /**
                * Called once the graph editor stopped execution. Typically used only in the graph editor when testing graphs.
                */
            onStop?: (node: GraphNode, target: any, scene: Scene) => void;
            /**
                * Can be implemented by the node, defines the list of available inputs not added by default to add on the fly.
                */
            onGetInputs?: () => [string, (string | number)][];
            /**
                * Can be implemented by the node, defines the list of available outputs not added by default to add on the fly.
                */
            onGetOutputs?: () => [string, (string | number)][];
            /**
                * Custom function that can be used to draw a text helper for the background.
                */
            drawBackground?: (node: GraphNode, targetName: string) => string;
            /**
                * All available parameters while calling the function on the current object being used.
                */
            parameters?: {
                    /**
                        * The name of the input to take as parameter.
                        */
                    inputName?: string;
                    /**
                        * The name of the property to take as parameter.
                        */
                    propertyName?: string;
                    /**
                        * Sets wether or not the parameter is optional.
                        */
                    optional?: boolean;
                    /**
                        * The type of output. Means the output value type.
                        */
                    type: InputOutputType;
            }[];
            /**
                * All the available properties allowing to customize the node.
                */
            properties?: {
                    /**
                        * The name of the property.
                        */
                    name: string;
                    /**
                        * Defines the type of the property.
                        */
                    type: InputOutputType;
                    /**
                        * Defines all the possible enums for the current parameters.
                        * @example "Space.WORLD"
                        */
                    enums?: string[];
                    /**
                        * Defines the target where to take the appropriate value of the enum.
                        * If not, provided, enums will work as string only.
                        */
                    enumsTarget?: any;
                    /**
                        * Defines the defualt value of the property.
                        */
                    defaultValue: SupportedTypes;
            }[];
            /**
                * The collection of widgets for the node.
                */
            widgets?: IWidget[];
    }
    export abstract class IGraphNode {
            /**
                * The graph reference used to retrieve object etc.
                */
            graph?: LGraph;
            /**
                * The type of the node (automatically set).
                */
            type?: string;
            /**
                * Sets or gets wether or not the node is removable (automatically set).
                */
            removable?: boolean;
            /**
                * Adds a new input to the node.
                * @param name the name of the input.
                * @param type the type of the input.
                */
            addInput?(name: string, type: string): void;
            /**
                * Removes an input from the node at the given index.
                * @param index the index of the input to remove.
                */
            removeInput?(index: number): void;
            /**
             * Adds a new output to the node.
             * @param name the name of the output.
             * @param type the type of the output.
             */
            addOutput?(name: string, type: string): void;
            /**
                * Removes an output from the node at the given index.
                * @param index the index of the output to remove.
                */
            removeOutput?(index: number): void;
            /**
                * Returns the data of the given input index.
                * @param index the index of the input in inputs list.
                */
            getInputData?<T extends any>(index: number): T;
            /**
                * Sets the given data to the given output index.
                * @param index the index of the output to set its data.
                * @param data the data to set in the output.
                */
            setOutputData?(index: number, data: any): void;
            /**
                * Triggers the given slot to activate the connected node(s).
                * @param index the index of the slot to trigger in the current node.
                */
            triggerSlot?(index: number): void;
            /**
                * Adds a new property to the .properties dictionary for the current node.
                * @param name the name of the property to store in the dictionary.
                * @param value the value of the property to store in the dictionary.
                */
            addProperty?(name: string, value: any): void;
            /**
                * Can be implemented by the node, defines the list of available inputs not added by default to add on the fly.
                */
            onGetInputs?(): [string, (string | number)][];
            /**
                * Can be implemented by the node, defines the list of available outputs not added by default to add on the fly.
                */
            onGetOutputs?(): [string, (string | number)][];
            /**
                * Adds the given widget to the node.
                */
            addWidget?(type: string, name: string, value: any, callback: (value: any, graph: LGraphCanvas, node: GraphNode) => void, options: any): any;
            /**
                * Sets if the canvas used to render to node should be set as dirty to force re-render.
                */
            setDirtyCanvas?(foreground: boolean, background: boolean): void;
            /**
                * Computes the size of the node according to the existing inputs, outputs and title.
                */
            computeSize?(): void;
            /**
                * Store of all available properties for the current node.
                */
            properties?: {
                    [index: string]: any;
            };
            /**
                * Defines the default shape of the node.
                */
            shape?: string;
            /**
                * Defines the current node position on (x,y).
                */
            pos?: number[];
            /**
                * Defines the current size in pixels of the node.
                */
            size?: number[];
            /**
                * Defines the current description of the node to be drawn in the node edition tool.
                */
            desc?: string;
            /**
                * Defines the current mode of the node. Can be:
                * - LiteGraph.NEVER: never executed.
                * - LiteGraph.ON_TRIGGER: only when an input is triggered.
                * - LiteGraph.ALWAYS: will always be executed.
                */
            mode?: number;
            /**
                * Defines the current color of the node in hexadecimal string. (titlebar)
                */
            color?: string;
            /**
                * Defines the current background color of the node in hexadecimal string. (background)
                */
            bgColor?: string;
            /**
                * Defines the current box color of the node in hexadecimal string. (box)
                */
            boxcolor?: string;
            /**
                * Flags set to the node
                */
            flags?: any;
            /**
                * Widgets available for the node.
                */
            widgets?: IWidget[];
            /**
                * Defines the store used to keep some temporary variables.
                */
            store: {
                    [index: string]: any;
            };
            /**
                * On connections changed for this node, change its mode according to the new connections.
                * @param type input (1) or output (2).
                * @param slot the slot which has been modified.
                * @param added if the connection is newly added.
                * @param link the link object informations.
                * @param input the input object to check its type etc.
                */
            onConnectionsChange(type: number, slot: number, added: boolean, link: any, input: any): void;
            /**
                * Sets the node's color according to its mode.
                * @param node the node to configure its color according to its current mode.
                * @see .mode
                */
            static SetColor(node: IGraphNode): void;
            /**
                * On the background is drawn, draw custom text.
                * @param ctx the canvas 2d context reference.
                * @param graph the graph canvas reference.
                * @param canvas the canvas reference where to draw the text.
                * @param text the text to draw.
                */
            onDrawBackground(ctx: CanvasRenderingContext2D, graph: LGraphCanvas, canvas: HTMLCanvasElement, text?: string): void;
            /**
                * Sets the node as warning.
                */
            setNodeState(warning: boolean): void;
            /**
                * Gets or sets wether of not if the node has been loaded and ready.
                */
            static Loaded: boolean;
            /**
                * Registers the given node to the registered node types.
                * @param path the path of the node in context menu.
                * @param ctor the constructor of the node.
                */
            static RegisterNode(path: string, ctor: (new (description: IGraphNodeDescriptor) => IGraphNode)): void;
    }
}

